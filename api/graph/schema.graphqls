# This schema definition is available in the public domain, or under the terms
# of CC-0, at your choice.
scalar Cursor
scalar Time

# This used to decorate fields which are only accessible to internal users;
# that is, used by each sr.ht service to communicate with the others.
#
# Note that the meta.sr.ht GraphQL API has more @internal fields than most of
# our APIs. In particular note that the OAuth 2.0 APIs are /all/ internal;
# application developers are not expected to use these as part of the normal
# OAuth 2.0 registration or access grant process.
directive @internal on FIELD_DEFINITION

# Used to provide a human-friendly description of an access scope
# TODO: Do something with this in gqlgen
directive @scopehelp(details: String!) on ENUM_VALUE

enum AccessScope {
  AUDIT_LOG @scopehelp(details: "audit log")
  BILLING   @scopehelp(details: "billing history")
  PGP_KEYS  @scopehelp(details: "PGP keys")
  SSH_KEYS  @scopehelp(details: "SSH keys")
  PROFILE   @scopehelp(details: "profile information")
}

enum AccessKind {
  RO @scopehelp(details: "read")
  RW @scopehelp(details: "read and write")
}

# Decorates fields for which access requires a particular OAuth 2.0 scope with
# read or write access. For the meta.sr.ht API, you have access to all public
# information without any special permissions - user profile information,
# public keys, and so on.
directive @access(scope: AccessScope!, kind: AccessKind!) on FIELD_DEFINITION

# https://semver.org
type Version {
  major: Int!
  minor: Int!
  patch: Int!
  # If this API version is scheduled for deprecation, this is the date on which
  # it will stop working; or null if this API version is not scheduled for
  # deprecation.
  deprecationDate: Time
}

interface Entity {
  id: Int!
  created: Time!
  updated: Time!
  # The canonical name of this entity. For users, this is their username
  # prefixed with '~'. Additional entity types will be supported in the future.
  canonicalName: String!
}

enum UserType {
  UNCONFIRMED
  ACTIVE_NON_PAYING
  ACTIVE_FREE
  ACTIVE_PAYING
  ACTIVE_DELINQUENT
  ADMIN
  SUSPENDED
}

type User implements Entity {
  id: Int!
  created: Time!
  updated: Time!
  canonicalName: String!
  username: String!
  email: String!
  url: String
  location: String
  bio: String

  userType: UserType! @internal
  suspensionNotice: String! @internal

  sshKeys(cursor: Cursor): SSHKeyCursor! @access(scope: SSH_KEYS, kind: RO)
  pgpKeys(cursor: Cursor): PGPKeyCursor! @access(scope: PGP_KEYS, kind: RO)
}

type SSHKey {
  id: Int!
  created: Time!
  lastUsed: Time
  user: User! @access(scope: PROFILE, kind: RO)
  key: String!
  fingerprint: String!
  comment: String
}

# A cursor for enumerating a list of SSH keys
#
# If there are additional results available, the cursor object may be passed
# back into the same endpoint to retrieve another page. If the cursor is null,
# there are no remaining results to return.
type SSHKeyCursor {
  results: [SSHKey!]!
  cursor: Cursor
}

type PGPKey {
  id: Int!
  created: Time!
  user: User! @access(scope: PROFILE, kind: RO)
  key: String!
  fingerprint: String!
}

# A cursor for enumerating a list of PGP keys
#
# If there are additional results available, the cursor object may be passed
# back into the same endpoint to retrieve another page. If the cursor is null,
# there are no remaining results to return.
type PGPKeyCursor {
  results: [PGPKey!]!
  cursor: Cursor
}

type Invoice {
  id: Int!
  created: Time!
  cents: Int!
  validThru: Time!
  source: String
}

type OAuthGrant {
  id: Int!
  client: OAuthClient!
  issued: Time!
  expires: Time!
  tokenHash: String! @internal
}

type OAuthGrantRegistration {
  grant: OAuthGrant!
  grants: String!
  secret: String!
}

type OAuthClient {
  id: Int!
  uuid: String!
  redirectUrl: String!

  name: String!
  description: String
  url: String

  owner: Entity!
}

type OAuthClientRegistration {
  client: OAuthClient!
  secret: String!
}

type OAuthPersonalToken {
  id: Int!
  issued: Time!
  expires: Time!
  comment: String
}

type OAuthPersonalTokenRegistration {
  token: OAuthPersonalToken!
  secret: String!
}

# A cursor for enumerating a list of invoices
#
# If there are additional results available, the cursor object may be passed
# back into the same endpoint to retrieve another page. If the cursor is null,
# there are no remaining results to return.
type InvoiceCursor {
  results: [Invoice!]!
  cursor: Cursor
}

type AuditLogEntry {
  id: Int!
  created: Time!
  ipAddress: String!
  eventType: String!
  details: String
}

# A cursor for enumerating a list of audit log entries
#
# If there are additional results available, the cursor object may be passed
# back into the same endpoint to retrieve another page. If the cursor is null,
# there are no remaining results to return.
type AuditLogCursor {
  results: [AuditLogEntry!]!
  cursor: Cursor
}

type Query {
  # Returns API version information.
  version: Version!

  # Returns the authenticated user.
  me: User! @access(scope: PROFILE, kind: RO)

  # Returns a specific user
  userByID(id: Int!): User @access(scope: PROFILE, kind: RO)
  userByName(username: String!): User @access(scope: PROFILE, kind: RO)
  userByEmail(email: String!): User @access(scope: PROFILE, kind: RO)

  # Returns a specific SSH key by its fingerprint, in hexadecimal
  sshKeyByFingerprint(fingerprint: String!): SSHKey
    @access(scope: SSH_KEYS, kind: RO)

  # Returns a specific PGP key
  pgpKeyByKeyId(keyId: String!): PGPKey
    @access(scope: PGP_KEYS, kind: RO)

  # Returns invoices for the authenticated user
  invoices(cursor: Cursor): InvoiceCursor! @access(scope: BILLING, kind: RO)

  # Returns the audit log for the authenticated user
  auditLog(cursor: Cursor): AuditLogCursor! @access(scope: AUDIT_LOG, kind: RO)

  ###                                               ###
  ### The following resolvers are for internal use. ###
  ###                                               ###

  # Returns the revocation status of a given OAuth 2.0 token hash (SHA-512). If
  # the token or client ID has been revoked, this returns true, and the key
  # should not be trusted. Client ID is optional for personal access tokens.
  tokenRevocationStatus(hash: String!, clientId: String): Boolean! @internal

  # List of OAuth clients this user administrates
  oauthClients: [OAuthClient]! @internal

  # Returns a specific OAuth client (by database ID)
  oauthClientByID(id: Int!): OAuthClient @internal

  # Returns a specific OAuth client (by UUID)
  oauthClientByUUID(uuid: String!): OAuthClient @internal

  # Returns OAuth grants issued for the authenticated user
  oauthGrants: [OAuthGrant]! @internal

  # Resturns a list of personal OAuth tokens issued
  personalAccessTokens: [OAuthPersonalToken]! @internal
}

input UserInput {
  # Omit these fields to leave them unchanged, or set them to null to clear
  # their value.
  url: String
  location: String
  bio: String

  # Note: changing the user's email address will not take effect immediately;
  # the user is sent an email to confirm the change first.
  email: String
}

type Mutation {
  updateUser(input: UserInput): User! @access(scope: PROFILE, kind: RW)

  createPGPKey(key: String!): PGPKey! @access(scope: PGP_KEYS, kind: RW)
  deletePGPKey(id: Int!): PGPKey @access(scope: PGP_KEYS, kind: RW)

  createSSHKey(key: String!): SSHKey! @access(scope: SSH_KEYS, kind: RW)
  deleteSSHKey(id: Int!): SSHKey @access(scope: SSH_KEYS, kind: RW)

  # Causes the "last used" time of this SSH key to be updated.
  updateSSHKey(id: Int!): SSHKey! @access(scope: SSH_KEYS, kind: RO)

  ###                                               ###
  ### The following resolvers are for internal use. ###
  ###                                               ###

  # Registers an OAuth client. Only OAuth 2.0 confidental clients are
  # supported.
  registerOAuthClient(
    redirectUri: String!,
    clientName: String!,
    clientDescription: String,
    clientUrl: String): OAuthClientRegistration! @internal

  # Revokes this OAuth client, revoking all tokens for it and preventing future
  # use.
  revokeOAuthClient(uuid: String!): OAuthClient @internal

  # Revokes a specific OAuth grant.
  revokeOAuthGrant(hash: String!): OAuthGrant @internal

  # Issues an OAuth personal access token.
  issuePersonalAccessToken(grants: String, comment: String):
    OAuthPersonalTokenRegistration! @internal

  # Revokes a personal access token.
  revokePersonalAccessToken(id: Int!): OAuthPersonalToken @internal

  # Issues an OAuth 2.0 authorization code. Used after the user has consented
  # to the access grant request.
  issueAuthorizationCode(clientUUID: String!, grants: String!): String! @internal

  # Completes the OAuth 2.0 grant process and issues an OAuth token for a
  # specific OAuth client.
  issueOAuthGrant(authorization: String!,
    clientSecret: String!): OAuthGrantRegistration @internal
}
