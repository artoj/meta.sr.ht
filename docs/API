                                   meta.sr.ht

                               API DOCUMENTATION

The meta.sr.ht API is served over https and is largely read-only. It allows you
to authenticate sr.ht users with OAuth, access some account details, and set up
webhooks to notify you of activity.

                                 REQUEST FORMAT

Submit HTTP requests with the appropriate HTTP method as documented by the
endpoint (i.e. GET, POST, PUT). If you are asked to provide a request body,
encode it as application/json. Response bodies will be application/json and the
HTTP status code indicates the result of your request. Errors (4xx or 5xx HTTP
status codes) use the following format:

    {
      "errors": [                   An array of errors that occured
        {
          "field": "string",        The name of the field that caused the error.
                                    (optional)
          "code": "string",         A computer-friendly error code.
          "reason": "string"        A human-friendly error string.
        }
      ]
    }

Successful responses (2xx HTTP status codes) will use the response format
described in each endpoint's documentation. The following headers will be
included in responses:

    X-OAuth-Required            OAuth scope necessary to use this endpoint
    X-OAuth-Scopes              OAuth scopes your token is granted

In all requests, please set the User-Agent header to something unique, and
include some means for us to contact you. For example:

    User-Agent: Example application - https://example.org - admin@example.org

                                     TYPES

All standard JSON types (string, number, boolean, array, object, null) are
supported. Additionally, "datetime"s are supported by wrapping an ISO 8601
formatted datetime in a string (in UTC).

                                 AUTHENTICATION

To authenticate someone with their sr.ht account, you must register an OAuth
client (in your account settings: meta.sr.ht/oauth). When you do so, you will
receive a "client ID" and a "client secret". As the name implies, the latter
must be kept secret. The basic flow from here is thus:

1. Direct users to the authorization page (documented below) with a web browser.
2. The user enters their login details on meta.sr.ht and is presented with
   information about your request. They may then choose to approve your request
   to access their account.
3. We return the user to the URL of your choosing, and in the query string
   include an "exchange token".
4. From your application, you submit the exchange token, along with your client
   ID and client secret, to our exchange endpoint (documented below).
5. We issue you an "OAuth token", which you include with API requests as to
   authenticate.

AUTHORIZATION PAGE

In a web browser, direct your users to this page:

    https://meta.sr.ht/oauth/authorize?[args...]

In the query string, you may include the following information:

    client_id       required    Your client ID
    scopes          required    Which OAuth scopes (see below) you need
    redirect_uri    optional    Where to direct the user upon authorization
    state           optional    An arbitrary token (see below)

scopes is a comma-delimited list of OAuth scopes you wish to obtain. Depending
on which scopes you choose you may access a different subset of the API. Only
request what you need: the format of a scope is name:access, where name
determines which endpoints are affected and access is one of "read" or "write".
The available names are listed later in this document.

redirect_uri must begin with the same characters as the "Redirect URI" option in
your OAuth application configuration.

state is an arbitrary token you may choose to generate in your application
before redirecting the user to the authorization page. We will include this
token in the redirect back to your application, and you may use it to identify
the user or determine if the OAuth flow originated from you (as opposed to
someone else directing a user to the authorization page with your client ID), or
for any other use you can think of.

REDIRECT

On the authorization page, the user may agree to authorize your request. When
they decide, we will redirect them back to your redirect_uri (or the default set
for your OAuth client). In the query string, we will include:

    token       Your exchange token
    scopes      OAuth scopes the user has agreed to give you
    state       The state token you provided before, if present

Design your applications to support allowing the user to return different scopes
than the ones you asked for. A good practice is to ask for a minimal number of
OAuth scopes at first, and then direct the user back to the authorization page
to elevate your permissions as they ask your application to do tasks that
require it.

TOKEN EXCHANGE

Take the token from the query string we redirected to, and use it to perform the
following HTTP request:

POST /oauth/exchange
    Exchanges an exchange token for an OAuth token.

    {
      "client_id": "string",      Your client ID
      "client_secret": "string",  Your client secret
      "token": "string"           The exchange token
    }

    Response:

    {
      "token": "string",
      "expires": "datetime",
    }

token is the OAuth token you have been issued.

expires is the datetime your token will expire at.

In further requests you may include the following HTTP header to authenticate:

    Authorization: oauth <token>

Where <token> is your OAuth token. For example:

    Authorization: oauth 215ec72a2546bf09040b4b7ee67010125ddf847653c1dc40

                                 HTTP ENDPOINTS

All of these endpoints require authentication.

GET /api/profile
    Scopes: profile:read
    Returns a user's profile information. Each field returned corresponds to a
    setting at meta.sr.ht/profile.

    Response:

    {
      "username": "string",
      "email": "string",
      "url": "string",
      "location": "string",
      "bio": "string"
    }

GET /api/security/log?page=[page]
    Scopes: audit:read
    Returns a user's audit log.

    page    Which page of results to return (default: 0)

    Response:

    {
      "page": number,
      "total_pages": number,
      "total_results": number,
      "results": [
        {
          "id": number,
          "ip": "string",
          "action": "string",
          "details": "string",
          "occured": "string"
        },
        ...
      ]
    }

GET /api/keys/ssh?page=[page]
    Scopes: keys:read
    Returns a user's SSH keys.

    page    Which page of results to return (default: 0)

    Response:

    {
      "page": number,
      "total_pages": number,
      "total_results": number,
      "results": [
        {
          "id": number,
          "name": "string",
          "fingerprint": "string",
          "authorized": "datetime",
          "last_used": "datetime"
        },
        ...
      ]
    }

GET /api/keys/pgp?page=[page]
    Scopes: keys:read
    Returns a user's PGP keys.

    page    Which page of results to return (default: 0)

    Response:

    {
      "id": number,
      "page": number,
      "total_pages": number,
      "total_results": number,
      "results": [
        {
          "id": number,
          "email": "string",
          "key_id": "string",
          "authorized": "datetime"
        },
        ...
      ]
    }

                                 META WEBHOOKS

You can register for webhooks to be notified with the user updates some account
information. When such an event happens, we will send an HTTP request to the
endpoint you specify with details of the event. A number of endpoints help you
manipulate your webhooks. You do not need any particular OAuth scopes to set
webhooks, but you have to have read access to the resources you want to be
notified about.

GET /api/webhooks?page=[page]
    Returns a list of your active webhooks.

    page    Which page of results to return (default: 0)

    Response:

    {
      "page": number,
      "total_pages": number,
      "total_results": number,
      "results": [
        {
          "id": number,
          "action": "string",
          "url": "url",
          "last_delivery": "datetime"
        },
        ...
      ]
    }

DELETE /api/webhooks/:id
    Deletes a webhook.

    Response:

    {
    }

POST /api/webhooks
    Creates a new webhook. Note that you can only have one webhook per action
    type. Actions are in the form of "type:event", such as "profile:updated".
    You may subscribe to "type:*" with one webhook.

    {
      "action": "string",
      "url": "url"
    }

    Response:

    {
      "id": number,
      "action": "string",
      "url": "url",
      "last_delivery": "datetime"
    }

WEBHOOK REQUEST FORMAT

The HTTP request sent to the supplied URL will use this structure:

    {
      "action": "string",
      "occured": "datetime",
      "username": "string",
      "details": {
        ...
      }
    }

The structure of the details object varies depending on what sort of event
occured.

ACTIONS

profile:updated
    Occurs when the user updates their profile information.

    {
      "username": "string",
      "email": "string",
      "url": "string",
      "location": "string",
      "bio": "string"
    }

ssh-key:added
    Occurs when the user adds an SSH key.

    {
      "id": number,
      "name": "string",
      "fingerprint": "string",
      "authorized": "datetime",
      "last_used": "datetime"
    }

ssh-key:removed
    Occurs when the user removes an SSH key.

    {
      "id": number,
      "name": "string",
      "fingerprint": "string",
      "authorized": "datetime",
      "last_used": "datetime"
    }

pgp-key:added
    Occurs when the user adds a PGP key.

    {
      "id": number,
      "email": "string",
      "key_id": "string",
      "authorized": "datetime"
    }

pgp-key:removed
    Occurs when the user removes a PGP key.

    {
      "id": number,
      "email": "string",
      "key_id": "string",
      "authorized": "datetime"
    }

                           THIRD-PARTY AUTHORIZATION

Third-party software may offer an API for you to manipulate their user's data
based on their sr.ht account. To faciliate this, meta.sr.ht provides a modified
OAuth flow. Consider three parties:

- meta: this API
- service: the third party service you want to authenticate with via meta.sr.ht
- you: self explanatory

Let's say for example you want to use the git.sr.ht API. To authenticate with it
as a specific meta.sr.ht account, perform the OAuth flow normally, but include
an extra parameter when you send the user to the authorization page:

    transfer_to     client_id of the OAuth client to transfer the token to

When you receive your exchange token, instead communicate it with the
third-party via whatever API method they provide to do so. The third party
service may use their client secret to obtain an OAuth token. You may also use
the exchange token, but be aware that you will receive a different OAuth token.

Typically, when you use the third-party service's authorization endpoint to hand
off the exchange token, that service will return to you some kind of token to
authenticate against its own API with.
